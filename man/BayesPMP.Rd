% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BayesPMP.R
\name{BayesPMP}
\alias{BayesPMP}
\title{Estimates Bayesian Partial M-Probit via Gibbs Sampling.}
\usage{
BayesPMP(formula, data, prpslid, gntid, groups = NULL, R, V = NULL,
  qweights = NULL, pweights = NULL, qvote = NULL, pvote = NULL,
  pslct = NULL, qslct = NULL, b0 = NULL, invB0 = NULL, e0 = 0.1,
  f0 = 0.1, chib95 = FALSE, betastart = NULL, omegastart = NULL,
  burnin = 500, ngibbs = 2000, verbose = 500, thin = 1, chains = 2,
  seed = 42, rate = 200, step = 0.05, adapt = TRUE, monitor = FALSE)
}
\arguments{
\item{formula}{(required) a formula object of the form \code{ y | b ~ x1 + ... xK}. All \code{x} and \code{b} must be 
without missing values. For each proposal, the \code{b} vector must be identical 
across members. \code{y |} is optional supplying known vote choices for a proposal.
Only used if all votes for a subset of proposal are none-missing.}

\item{data}{(required) a \code{data.frame} object that contains all data used in \code{formula} and the variables specified
in \code{prpslid} and \code{gntid}.}

\item{prpslid}{(required) the name for the consecutive numbered (\eqn{[1, J]}) integer variable that identifies 
each proposal uniquely in the data.}

\item{gntid}{(required) the name for the consecutive numbered (\eqn{[1, M]}) integer variable that identifies 
each voting member in the data.}

\item{groups}{the name for the integer variable in \code{data} that identifies groups of proposals for which a varying intercept should be estimated.}

\item{R}{(required) the number of members that have to agree to pass a proposal excluding the 
members that have veto power. Can be a vector of length \code{n_distinct(prpslid)} or a single number.}

\item{V}{the number of veto members that have to agree to pass a proposal. Can 
can be a vector of length \code{n_distinct(prpslid)} or a single number. The function assumes that 
the first V members in the data are the once with veto power. That is, after sorting the data for each  
proposal by \code{gntid} the first \code{V} entries are used as they belong to members with 
with veto power.}

\item{b0}{the prior mean of length \eqn{K+1}. If \code{b0=NULL} the function assumes \code{b0=0}.}

\item{invB0}{the prior precision matrix of dimension \eqn{(K+1) \times (K+1)}. If \code{invB0=NULL}
the function assumes \code{invB0=solve(diag(K+1)*1000)} where \code{K} is the number of coefficients implied by \code{formula}.}

\item{chib95}{calculate the marginal likelihood using the method of Chib (1995)?}

\item{betastart}{the list of starting value vectors for \eqn{\beta}.}

\item{burnin}{the integer number of samples used as burn-in.}

\item{ngibbs}{the integer number of samples from the posterior distribution.}

\item{verbose}{integer number: use \code{0} for no output; use any positive natural number to report progress at each 
\code{verbose}-th iteration.}

\item{thin}{the n-th posterior draw to be recorded. Must be a number that yields a 
positive integer when \code{ngibbs/thin}.}

\item{chains}{integer number for the number of chains.}

\item{seed}{integer number for the seeding value.}

\item{rate}{schedule for the adaption if \code{adapt=TRUE}.}

\item{step}{\eqn{\epsilon}-parameter if \code{adapt=TRUE}.}

\item{adapt}{if \code{TRUE} (default) the Gibbs sampler uses the more efficient algorithm 2 in Marbach (2016) otherwise algorithm 1.}

\item{monitor}{if \code{adapt=TRUE} prints adaptation steps for each draw.}

\item{q/pweights}{integer matrix of dimension \code{M x T} where \code{T} is the number of distinct voting weights. The vote weights sorted by gntid.}

\item{q/pvote}{scalar or integer vector of length \code{J}. The threshold for the vote weights.}

\item{q/pslct}{integer vector of length \code{J}. Each entry refers to the applicable column in the \code{q/pweights} for a particular proposal \code{j}.}

\item{e0/f01}{the parameters for the inverse-gamma prior density if a varying intercept is included (\code{groups} is not \code{NULL})}
}
\value{
\code{coda} object of \code{ngibbs/thin} draws from the posterior distribution of the coefficients 
 	including the intercept. The \code{coda} object has 3 non-standard attributes: \code{type} which is set 
	to \code{consilium}, \code{formula} which is  set to \code{formula} used in the function syntax 
	and \code{timecode} recording the \code{Sys.time()} when the function finished. If \code{chib95=TRUE} the marginal 
 likelihood estimate is also included. 

#' @seealso \code{\link{summary.mcmc}}, \code{\link{plot.mcmc}} and other coda-functions.
}
\description{
\code{BayesPMP} obtains a set of draws from the posterior distribution of a (mixed) partial m-probit.
}
\details{
Let \eqn{x_{ij}} be a vector of length \eqn{K} that collects all observed covariates for one of \eqn{M} 
members and a proposal \eqn{j}. Let \eqn{y_{ij}} be the unobserved vote choice of member \eqn{i} for proposal \eqn{j}. 
Let \eqn{b_j} be the observed vector of length \eqn{J} that collects the observed decisions made by the \eqn{M} members
 according to a q-rule with threshold \eqn{R}. The model takes the following form: 
 
\deqn{Prob(b_j=0) = Prob( \sum_{i=1}^M y_{ij} < R) }
\deqn{Prob(y_{ij}=0) = \phi(x_{ij}\beta)}

where \eqn{\phi()} is the standard univariate normal distribution and \eqn{\beta} is the parameter vector of interest.
The prior density for \eqn{\beta} is a multivariate normal with user-specified prior mean vector 
and precision matrix. The function here simulates draws from the posterior density of \eqn{\beta}. 

Notice, that \code{BayesPMP}  can handle other voting rules than a q-rules with proposal-invariant threshold \eqn{R}.
The threshold and the number of members with veto powers are allowed to vary across proposals. Weighted voting rules are
also supported. 

If a varying intercept is included, it is assumed to be drawn from a normal density with a variance that has an inverse-gamma prior density. 

See the references for the derivation of the posterior and a description of the Gibbs sampler. The default (\code{adapt=TRUE}) uses 
algorithm 2 in Marbach (2016). The function runs in \code{C++}.

The marginal likelihood (\code{chib95=TRUE}) can not (yet) be calculated if a) a varying intercept is included (\code{groups} is \code{NULL}), 
b) the voting rule varies across decisions or c) with a partially observed voting record.

See \code{coda} documentation for help analyzing posterior samples. It is important to assess the convergence of the chains.
}
\examples{
 \dontrun{
 # Example 1: q-rule # 
 ###########################

	require(plyr)

 set.seed(10)
 J <- 250 	# proposal 
 I <- 10 	# members
 R <- 6		# majority threshold

 # Simualte roll call voting record 
 beta <- c(0,0.4)
 X <- data.frame(x0=1,x1=runif(J*I,-2,2))
 y <- rbinom(J*I, 1, pnorm(as.matrix(X) \%*\% beta))

 # Bundle data with IDs
 data <- data.frame(gntid=sort(rep(seq(1,I), J)), 
 		prpslid=rep(seq(1,J), I), 
 		y, X)
 
 # Generate decision record 
 data <- ddply(data, "prpslid" ,function(x) { 
 		x$y.agg <- as.numeric(sum(x$y) >= R)
 		return(x)
 		})
 
 # Estimate partial m-probit 
 m1 <- BayesPMP(formula=y.agg ~ x1,R=R, prpslid="prpslid", gntid="gntid", data=data)

 # Generate selected individual voting record 
 data$y.slct <- ifelse(data$prpslid <= 10, data$y, NA)

 # Estimate partial m-probit with observed votes 
 m2 <- BayesPMP(formula=y.slct | y.agg ~ x1,R=R, prpslid="prpslid", gntid="gntid", data=data)
 
 summary(m1)
 summary(m2)

 # Example 2: Weighted q-rule 
 #############################

 require(plyr)
 
 set.seed(10)
 J <- 250 	# proposal 
 I <- 10 	# members
 R <- 6		# majority threshold
 voteweights <- matrix(0L, I, 1)
 voteweights[1:3,1] <- 10
 qvote <- 20
 qslct <- rep(1, J)

 # Simualte roll call voting record 
 beta <- c(0,0.4)
 X <- data.frame(x0=1,x1=runif(J*I,-2,2))
 y <- rbinom(J*I, 1, pnorm(as.matrix(X) \%*\% beta))

 # Bundle data with IDs
 data <- data.frame(gntid=sort(rep(seq(1,I), J)), 
 		prpslid=rep(seq(1,J), I), 
 		y, X)
 
 # Generate decision record 
 data <- ddply(data, "prpslid" ,function(x) { 
 		x$y.agg <- as.numeric( sum(x$y) >= R & (x$y \%*\% voteweights) >= qvote )
 		return(x)
 		})
 
 # Estimate partial m-probit 
 m2 <- BayesPMP(formula=y.agg ~ x1,R=R, prpslid="prpslid", 
		gntid="gntid", data=data, qweights=voteweights, qvote=qvote, qslct=qslct)
 summary(m2)
 }


}
\references{
Marbach, Moritz. 2016. `Analyzing Decision Records from Committees.'' Working Paper.

	Chib, Siddhartha. 1995. Marginal Likelihood from the Gibbs Output. Journal of the American Statistical Association 90(432), 1313â€“1321.
}

