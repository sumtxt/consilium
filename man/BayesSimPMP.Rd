% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BayesSimPMP.R
\name{BayesSimPMP}
\alias{BayesSimPMP}
\title{Simulates Posterior Predicted Probabilities for Proposal Passage from a Partial M-Probit Posterior}
\usage{
BayesSimPMP(posterior, data, prpslid, gntid, R, V = NULL, qweights = NULL,
  pweights = NULL, qvote = NULL, pvote = NULL, pslct = NULL,
  qslct = NULL, method = "mc", NSIM = 500, verbose = 500, seed = NULL,
  postSamp = NULL, postMean = FALSE)
}
\arguments{
\item{posterior}{(required) a posterior object from \code{BayesPMP()}. Can have multiple chains.}

\item{data}{(required) a \code{data.frame} object that contains all RHS variables used in the \code{formula} to obtain 
posterior using \code{BayesPMP()}.}

\item{prpslid}{(required) the name for the consecutive numbered (\eqn{[1, J]}) integer variable that identifies 
each proposal uniquely in the data.}

\item{gntid}{(required) the name for the consecutive numbered (\eqn{[1, M]}) integer variable that identifies 
each voting member in the data.}

\item{R}{(required) the number of members that have to agree to pass a proposal excluding the 
members that have veto power. Can be a vector of length \code{n_distinct(prpslid)} or a single number.}

\item{V}{the number of veto members that have to agree to pass a proposal. Can 
can be a vector of length \code{n_distinct(prpslid)} or a single number. The function assumes that 
the first V members in the data are the once with veto power. That is, after sorting the data for each  
proposal by \code{gntid} the first \code{V} entries are used as they belong to members with 
with veto power.}

\item{NSIM}{integer. The number of Monte Carlo simulations to run.}

\item{verbose}{integer number: use \code{0} for no output; use any positive natural number to report progress at each 
\code{verbose}-th iteration.}

\item{seed}{integer number for the seeding value.}

\item{postSamp}{number of posterior samples to be used in the calculations.}

\item{postMean}{only calculate the predicted probabilities for the posterior mean?}

\item{groups}{the name for the integer variable in \code{data} that identifies groups of proposals for which a varying intercept should be estimated.}

\item{q/pweights}{integer matrix of dimension \code{M x T} where \code{T} is the number of distinct voting weights. The vote weights sorted by gntid.}

\item{q/pvote}{scalar or integer vector of length \code{J}. The threshold for the vote weights.}

\item{q/pslct}{integer vector of length \code{J}. Each entry refers to the applicable column in the \code{q/pweights} for a particular proposal \code{j}.}
}
\value{
\code{matrix} object of size \code{max(prpslid)} times \code{niter(posterior) * nchain(posterior)}.
}
\description{
\code{BayesSimPMP} simulates posterior predicted probabilities for an estimated partial m-probit using Monte Carlo.
}
\details{
To obtain the posterior density for the predicted probability that proposal \code{j} passes, the function uses a 
a Monte Carlo algorithm. Conditional on the covariates for all voting members with respect to proposal \code{j} and a single draw from 
the posterior density of the coefficients, it simulates \code{NSIM} vote profiles. The number of 
adoption decisions implied by these vote profiles relative to \code{NSIM} gives an estimate about the probability for the passage of the 
\code{j^{th}} proposal. Iterating over all posterior draws gives the posterior density for the predicted probability that proposal \code{j} passes. 

The function runs in \code{C++}.

The function can not (yet) obtain posterior predicted probabilities if the posterior includes a varying intercept.
}
\examples{
 \dontrun{
 # Example 1: Using Simulated Data # 
 ###########################

	require(plyr)

 set.seed(10)
 J <- 250 	# proposal 
 I <- 10 	# actors
 R <- 6		# majority threshold

 # Simualte roll call voting record 
 beta <- c(0,0.4)
 X <- data.frame(x0=1,x1=runif(J*I,-2,2))
 y <- rbinom(J*I, 1, pnorm(as.matrix(X) \%*\% beta))

 # Bundle data with IDs
 data <- data.frame(gntid=sort(rep(seq(1,I), J)), 
 		prpslid=rep(seq(1,J), I), 
 		y, X)
 
 # Generate decision record 
 data <- ddply(data, "prpslid" ,function(x) { 
 		x$y.agg <- as.numeric(sum(x$y) >= R)
 		return(x)
 		})
 
 # Estimate partial m-probit 
 m1 <- BayesPMP(formula=y.agg ~ x1,R=R, prpslid="prpslid", gntid="gntid", data=data)

 # Simulate posterior predicted probability for first proposal (prpslid==1).
 m1sim <- BayesSimPMP(m1, R=R, prpslid="prpslid", gntid="gntid",data=data[data$prpslid==1,])
 hist(m1sim, breaks=100)
 }

}
\references{
Marbach, Moritz. 2016. `Analyzing Decision Records from Committees.'' Working Paper.
}

