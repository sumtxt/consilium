% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MaxLikPMP.R
\name{MaxLikPMP}
\alias{MaxLikPMP}
\title{Estimates Bayesian Partial M-Probit via Maximum Likelihood.}
\usage{
MaxLikPMP(formula, data, prpslid, gntid, R, I = NULL, V = NULL,
  qweights = NULL, pweights = NULL, qvote = NULL, pvote = NULL,
  betastart = NULL, verbose = TRUE, method = "BFGS", control = list(),
  whichloglik = NULL, betahat = NULL)
}
\arguments{
\item{formula}{(required) a formula object of the form \code{b ~ x1 + ... xK}. All \code{x} and \code{b} must be 
without missing values. Intercept is included automatically. For each proposal, the \code{b} vector must be identical 
across actors.}

\item{data}{(required) a data.frame object that contains all data used in the \code{formula} and the variables specified
in \code{prpslid} and \code{gntid}.}

\item{prpslid}{(required) the name for the consecutive numbered (\eqn{[1, J]}) integer variable that identifies 
each proposal uniquely in the data.}

\item{gntid}{(required) the name for the consecutive numbered (\eqn{[1, M]}) integer variable that identifies 
each actor in the data.}

\item{R}{(required) integer. the number of actors that have to agree to pass a proposal excluding the 
actors that have veto power.}

\item{I}{integer. The number of actors. Only required if \code{max(gntid)==1},}

\item{V}{integer. The number of actors that have have to agree to pass a proposal. The function 
assumes that the first V actors in the data are the once with veto power. That is, after sorting
the data for each proposal by \code{gntid} the first \code{V} entries are used as they 
belong to actors with veto power.}

\item{betastart}{a vector of starting value vectors for \eqn{\beta}. It is advised to supply starting values.}

\item{verbose}{logical value. Use \code{TRUE} for progress report, \code{FALSE} for no output.}

\item{method}{string value. Which of \code{optim()}'s optimization methods to use?}

\item{control}{passed on to \code{optim()}.}

\item{whichloglik}{if set to \code{"comb"} the function will not make any attempt to find a more 
efficient representation of the likelihood function (see notes below)}

\item{q/pweights}{integer matrix of dimension \code{M x 1}. The vote weights sorted by gntid.}

\item{q/pvote}{scalar. The threshold for the vote weights.}

\item{behahat}{a matrix of size \code{K x H} of known \code{K} coefficient values for the model 
for which the \code{H} likelihood values are computed}
}
\value{
\code{maxlikpmp} object with the following slots: 
\itemize{
	\item \code{n} the number of observation for the RHS of the \code{formula}
	\item \code{coef} estimated coefficients
	\item \code{coefnames} the corresponding variable names for the coefficients 
	\item \code{hessian} the estimated hessian
	\item \code{form} the formula used 
	\item \code{code} the \code{optim()} convergence code 
	\item \code{iter} the number of iterations from \code{optim()}
	\item \code{I} the number of actors 
	\item \code{R} the majority threshold 
	\item \code{V} the number of actors with veto power
}

The standard R functions \code{vcov}, \code{coef}, \code{logLik} and \code{summary} can be used on any \code{maxlikpmp} object.
}
\description{
\code{MaxLikPMP} obtains MLE estimates for a partial m-probit (pmp).
}
\details{
Let \eqn{x_{ij}} be a vector of length \eqn{K} that collects all observed covariates for one of \eqn{M} 
actors and a proposal \eqn{j}. Let \eqn{y_{ij}} be the unobserved vote choice of actor \eqn{i} for proposal \eqn{j}. 
Let \eqn{b_j} be the observed vector of length \eqn{J} that collects the observed decisions made by the \eqn{M} actors
 according to a q-voting rule with threshold \eqn{R}. The model takes the following form: 
 
\deqn{Prob(b_j=0) = Prob( \sum_{i=1}^M y_{ij} < R) }
\deqn{Prob(y_{ij}=0) = \phi(x_{ij}\beta)}

where \eqn{\phi()} is the standard univariate normal distribution and \eqn{\beta} is the parameter vector of interest.


Different to \code{BayesPMP(.)} this function can not handle proposal-specific voting rules, partially observed 
voting records or varying intercepts.  


Unless \code{betahat} is supplied, the function optimizes the implied likelihood using \code{optim()}. 
If \code{betahat} is supplied it computes the likelihood given using \code{betahat} as coefficients. 

To make the computation as efficient as possible, it attempts to take advantage of two special cases of the partial m-probit likelihood. 

a) If \code{max(gntid)==1} and \code{p/qweights==NULL} the function assumes that all 
covariate values are the same across actors for each proposal. In this case the likelihood 
is equivalent to a Bernoulli likelihood with a special (voting-rule depended) link function that Marbach (2016) refers to as 'B-link'. 

b) If \code{p/qweights==NULL}, the likelihood is the product of Poisson’s Binomial distribution functions 
which can be efficiently calculated using the discrete Fourier transform of the distribution's characteristic 
function (Hong 2013). 


If none of the special cases applies the likelihood is computed by summing across the probabilities of all 
potential voting coalition implied by the voting rule. Even for moderately sized committees 
this computation is very time- and memory-intensive. To force the function to not attempt to detect a special 
case set \code{whichloglik} to \code{"comb"}.
}
\examples{
 \dontrun{
 # Example 1: Using Simulated Data # 
 ###########################

 require(plyr)

 set.seed(10)
 J <- 250 	# proposal 
 I <- 10 	# actors
 R <- 6		# majority threshold

 # Simualte roll call voting record 
 beta <- c(0,0.4)
 X <- data.frame(x0=1,x1=runif(J*I,-2,2))
 y <- rbinom(J*I, 1, pnorm(as.matrix(X) \%*\% beta))

 # Bundle data with IDs
 data <- data.frame(gntid=sort(rep(seq(1,I), J)), 
 		prpslid=rep(seq(1,J), I), 
 		y, X)
 
 # Generate decision record 
 data <- ddply(data, "prpslid" ,function(x) { 
 		x$y.agg <- as.numeric(sum(x$y) >= R)
 		return(x)
 		})
 
 # Estimate partial m-probit 
 m1 <- MaxLikPMP(formula=y.agg ~ x1, prpslid="prpslid", gntid="gntid", data=data, I=I, R=R)

 summary(m1)

 # Plot log-likelihood function
 require(lattice)

 beta0 <- beta1 <- seq(-2,2,length=30)
 beta <- expand.grid(beta0,beta1)

 logliks <- MaxLikPMP(formula=y.agg ~ x1, prpslid="prpslid", gntid="gntid",
			     data=data, I=I, R=R, betahat=as.matrix(beta))

 logliks <- data.frame(loglik = logliks * (-1), beta0=beta[,1], beta1=beta[,2])

 wireframe(loglik ~ beta0 + beta1, data=logliks, 
	    shade=TRUE, main="Log-Likelihood", scales=list(arrows=FALSE) , zlim=c(-500,0) )


 # Example 2: Using Simulated Data # 
 ###########################

 No variation across actors for a proposal. Uses B-Link. 

 require(plyr)

 set.seed(10)
 J <- 250 	# proposal 
 I <- 10 	# actors
 R <- 6		# majority threshold

 # Simualte recorded votes
 beta <- c(0,0.4)
 X <- data.frame(x0=1,x1=rep(runif(J,-2,2), I) ) # changed compared to Ex.1
 y <- rbinom(J*I, 1, pnorm(as.matrix(X) \%*\% beta))

 # Bundle data with IDs
 data <- data.frame(gntid=sort(rep(seq(1,I), J)), 
 		prpslid=rep(seq(1,J), I), 
 		y, X)
 
 # Generate decision record 
 data <- ddply(data, "prpslid" ,function(x) { 
 		x$y.agg <- as.numeric(sum(x$y) >= R)
 		return(x)
 		})
 
 # Estimate partial m-probit 
 m2 <- MaxLikPMP(formula=y.agg ~ x1, prpslid="prpslid", gntid="gntid", data=data[data$gntid==1,], I=I, R=R)

 summary(m2)

 }


}
\references{
Marbach, Moritz. 2016. `Analyzing Decision Records from Committees.'' Working Paper.

 Hong, Yili. 2013. On Computing the Distribution Function for the Poisson Binomial Distribution. Computational Statistics & Data Analysis 59, 41–51.
}
\seealso{
\code{\link{optim}}
}

